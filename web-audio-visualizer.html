<dom-module id="web-audio-visualizer">
  <template>
    <style>
      :host {
        display: block;
        width: 100%;
        height: auto;
        max-width: 100%;
      }

      :host canvas {
        display: block;
        width: 100%;
        height: auto;
        max-width: 100%;
      }
    </style>
    <canvas id="canvas"></canvas>
  </template>
  <script>
    /**
     * `web-audio`
     * Provides a declarative way of working with the web audio API.
     *
     * @customElement
     * @polymer
     * @demo demo/index.html
     */
    class WebAudioVisualizer extends Polymer.Element {
      static get is () { return 'web-audio-visualizer'; }
      static get properties () {
        return {
          for: {
            type: String,
            value: false
          },

          type: {
            type: String,
            value: "wave"
          },

          width: {
            type: Number,
            value: 800
          },

          height: {
            type: Number,
            value: 800
          },

          smoothing: {
            type: Number,
            value: 0.9
          },

          size: {
            type: Number,
            value: 1024
          },

          context: {
            type: Object,
            value: false
          },

          canvas: {
            type: Object,
            value: false
          },

          analyser: {
            type: Object,
            value: false
          },

          renderer: {
            type: Function,
            value: () => {
              return false;
            }
          },

          _bufferLength: {
            type: Number,
            value: false
          },

          _dataArray: {
            type: Array,
            value: false
          },
        };
      }

      ready () {
        super.ready();

        const top = document.querySelector(`web-audio[name="${this.for}"]`);

        if (typeof top.visualizers !== "object") {
          top.visualizers = [];
        }

        top.visualizers.push(this);
      }

      connect (context, destination) {
        this.context = context;

        this.analyser = this.context.createAnalyser();
        this.analyser.connect(destination);

        this.freqs = new Uint8Array(this.analyser.frequencyBinCount);
        this.times = new Uint8Array(this.analyser.frequencyBinCount);

        if (this.type === "webgl") {
          this.canvas = this.$.canvas.getContext('webgl') || this.$.canvas.getContext('experimental-webgl');
          this._initWebgl();
        } else {
          this.canvas = this.$.canvas.getContext('2d');
        }

        requestAnimationFrame(this.draw.bind(this));
      }

      draw () {
        this.analyser.smoothingTimeConstant = this.smoothing;
        this.analyser.fftSize = this.size;

        // Get the frequency data from the currently playing music
        this.analyser.getByteFrequencyData(this.freqs);
        this.analyser.getByteTimeDomainData(this.times);

        if (this.type === "webgl") {
          this.$.canvas.width = this.width;
          this.$.canvas.height = this.height * .75;
        } else {
          var width = Math.floor(1/this.freqs.length, 10);
          this.$.canvas.width = width || this.width;
          this.$.canvas.height = this.height;
        }

        switch (this.type) {
          case "wave":
            this.wave();
          break;

          case "bars":
            this.bars();
          break;

          case "webgl":
            this.webgl();
          break;
        }

        requestAnimationFrame(this.draw.bind(this));
      }

      wave () {
        // Draw the time domain chart.
        for (var i = 0; i < this.analyser.frequencyBinCount; i++) {
          var value = this.times[i];
          var percent = value / 256;
          var height = this.height * percent;
          var offset = this.height - height - 0;
          var barWidth =  this.width/this.analyser.frequencyBinCount;
          this.canvas.fillStyle = 'black';
          this.canvas.fillRect(i * barWidth, offset, 4, 4);
        }
      }

      bars () {
        // Draw the frequency domain chart.
        for (var i = 0; i < this.analyser.frequencyBinCount; i++) {
          var value = this.freqs[i];
          var percent = value / 256;
          var height = this.height * percent;
          var offset = this.height - height;
          var barWidth = (this.width/this.analyser.frequencyBinCount) + 1;
          var hue = i/this.analyser.frequencyBinCount * 360;
          this.canvas.fillStyle = 'hsl(' + hue + ', 100%, 50%)';
          this.canvas.fillRect(i * barWidth, offset, barWidth, height);
        }
      }

      webgl () {
        this.canvas.uniform1f(this.fragTime, this.context.currentTime)
        this._copyAudioDataToTexture();
        this._renderQuad();
      }

      custom () {
        this.renderer();
        // Move paint logic here
      }

      _initWebgl () {
        const vbo = this.canvas.createBuffer();
        this.canvas.bindBuffer(this.canvas.ARRAY_BUFFER, vbo);
        const vertices = new Float32Array([-1, -1, 1, -1, -1, 1, 1, 1]);
        this.canvas.bufferData(this.canvas.ARRAY_BUFFER, vertices, this.canvas.STATIC_DRAW)
        this.canvas.vertexAttribPointer(0, 2, this.canvas.FLOAT, false, 0, 0)

        this.vertex = this.querySelector('web-audio-visualizer-shader[type="vertex"]').innerText;
        this.fragment = this.querySelector('web-audio-visualizer-shader[type="fragment"]').innerText;

        this.fragShader = this._createShader();

        const fragPosition = this.canvas.getAttribLocation(this.fragShader, 'position');
        this.canvas.enableVertexAttribArray(fragPosition);
        this.fragTime = this.canvas.getUniformLocation(this.fragShader, 'time');
        this.canvas.uniform1f(this.fragTime, this.context.currentTime);
        const fragResolution = this.canvas.getUniformLocation(this.fragShader, 'resolution');
        this.canvas.uniform2f(fragResolution, this.width, this.height);
        this.fragSpectrumArray = new Uint8Array(4 * this.freqs.length);
        const fragSpectrum = this._createTexture(this.canvas);
      }

      _renderQuad () {
        this.canvas.drawArrays(this.canvas.TRIANGLE_STRIP, 0, 4)
      }

      _createTexture () {
        const texture = this.canvas.createTexture();
        this.canvas.bindTexture(this.canvas.TEXTURE_2D, texture);
        this.canvas.texParameteri(this.canvas.TEXTURE_2D, this.canvas.TEXTURE_MIN_FILTER, this.canvas.LINEAR);
        this.canvas.texParameteri(this.canvas.TEXTURE_2D, this.canvas.TEXTURE_WRAP_S, this.canvas.CLAMP_TO_EDGE);
        this.canvas.texParameteri(this.canvas.TEXTURE_2D, this.canvas.TEXTURE_WRAP_T, this.canvas.CLAMP_TO_EDGE);
        return texture;
      }

      _createShader () {
        const vertexShader = this.canvas.createShader(this.canvas.VERTEX_SHADER);
        this.canvas.shaderSource(vertexShader, this.vertex);
        this.canvas.compileShader(vertexShader);
        if (!this.canvas.getShaderParameter(vertexShader, this.canvas.COMPILE_STATUS)) {
          throw new Error(this.canvas.getShaderInfoLog(vertexShader));
        }

        const fragmentShader = this.canvas.createShader(this.canvas.FRAGMENT_SHADER)
        this.canvas.shaderSource(fragmentShader, this.fragment);
        this.canvas.compileShader(fragmentShader);
        if (!this.canvas.getShaderParameter(fragmentShader, this.canvas.COMPILE_STATUS)) {
          throw new Error(this.canvas.getShaderInfoLog(fragmentShader));
        }

        const shader = this.canvas.createProgram();
        this.canvas.attachShader(shader, vertexShader);
        this.canvas.attachShader(shader, fragmentShader);
        this.canvas.linkProgram(shader);
        this.canvas.useProgram(shader);

        return shader;
      }

      _copyAudioDataToTexture (gl, audioData, textureArray) {
        for (let i = 0; i < this.freqs.length; i++) {
          this.fragSpectrumArray[4 * i + 0] = this.freqs[i] // R
          this.fragSpectrumArray[4 * i + 1] = this.freqs[i] // G
          this.fragSpectrumArray[4 * i + 2] = this.freqs[i] // B
          this.fragSpectrumArray[4 * i + 3] = 255           // A
        }
        this.canvas.texImage2D(this.canvas.TEXTURE_2D, 0, this.canvas.RGBA, this.freqs.length, 1, 0, this.canvas.RGBA, this.canvas.UNSIGNED_BYTE, this.fragSpectrumArray)
      }

      getFrequencyValue (freq) {
        var nyquist = this.context.sampleRate / 2;
        var index = Math.round(freq/nyquist * this.freqs.length);
        return this.freqs[index];
      }
    }

    window.customElements.define(WebAudioVisualizer.is, WebAudioVisualizer);
  </script>
</dom-module>
